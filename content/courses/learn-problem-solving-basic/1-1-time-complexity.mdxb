---
pageTitle: টাইম কমপ্লেক্সিটি - প্রোগ্রামিং সমস্যা সমাধানের হাতেখড়ি
title: টাইম কমপ্লেক্সিটি
description: টাইম কমপ্লেক্সিটি
---
প্রোগ্রামিং সমস্যা সমাধানের একটি গুরুত্বপূর্ণ বিষয় টাইম কমপ্লেক্সিটি। আমরা চারটি প্রশ্নের উত্তরে সমাধানের মাধ্যমে টাইম কমপ্লেক্সিটি মূল বিষয়টি বোঝার চেষ্টা করব।

## টাইম কমপ্লেক্সিটি কোন সমস্যার সমাধান করে বা টাইম কম্প্লিসিটি আমাদের কেন শেখা জরুরী?

প্রোগ্রামিংয়ের একটা সমস্যার সমাধান অনেক কয়েকটি অ্যালগরিদম ব্যবহার করে করা যায়। এখন এই অ্যালগরিদম গুলোর মধ্যে কোনটি সবচেয়ে ভালো এবং উপযোগী সেটি বোঝার জন্য টাইম কমপ্লেক্সিটির প্রয়োজন।

মনে করি, আমদের বাসা থেকে আমদের স্কুলের দূরত্ব 5 মিনিট। এখন আমরা বাসা থেকে বের হয়ে অনেকটা রাস্তা ঘুরে 10 মিনিট পরে স্কুলে পৌঁছাতে পারি। আবার সবচেয়ে কম দূরত্বের রাস্তাটি নির্ণয় করে, খুব সহজে 5 মিনিটের স্কুলে পৌঁছে যেতে পারি। এখানে আমরা সময় বিবেচনা করে কোন রাস্তাটি আমদের জন্য সবচেয়ে উপযোগী তা বুজতে পারছি। তাহলে কোন প্রোগ্রামিং সমস্যার সমাধানের জন্য কোন প্রোগ্রামটি ভাল তা আমরা কিভাবে বুজতে পারি?

প্রোগ্রামিং সমস্যা সমাধানে কোন অ্যালগরিদম সবচেয়ে ভালো এবং উপযোগী তা নির্ণয় করে টাইম কমপ্লেক্সিটি।

## টাইম কমপ্লেক্সিটি কি?

একটা অ্যালগরিদম রান করতে যতটুকু সময় লাগে তাকে সেই অ্যালগোরিদমের টাইম কমপ্লেক্সিটি বলে। এখন এই সংজ্ঞায় একটা সমস্যা আছে। চলো নিচের কোডটি লক্ষ্য করি,

```

for(let i =0;i<n;i++){
console.log(i)
}

```

আমরা একটি লুপ চালাবো যা 1 থেকে 5 পর্যন্ত চলবে । মনে করি, এই লুপটি চলতে সময় লাগবে 1 সেকেন্ড। এখন যদি n এর মান 10 হয় তাহলে এই লুপটি চলতে 2 সেকেন্ড সময় লাগবে। n মান যত বাড়বে প্রোগ্রামটি রান করতে সময় বেশি লাগে । এখান থেকে আমরা বুঝলাম টাইম কমপ্লেক্সিটি কোন অ্যালগোরিদমের ইনপুট এর মান কত বড় হবে তার ওপর নির্ভর করে ।

তাহলে টাইম কমপ্লেক্সিটির সঠিক সংজ্ঞা হবে,

কোন অ্যালগোরিদমের ইনপুট অনুসারে অ্যালগরিদম টি রান করতে যতটুকু সময় লাগে তাকে ওই অ্যালগোরিদমের টাইম কমপ্লেক্সিটি বলে।

এখানে কিন্তু রানটাইম বলতে, একটা প্রোগ্রাম বা এলগরিদম রান করতে মোট কত সময় লাগে তা বোঝায় না। এখন মনে করি, একটি সাধারণ কম্পিউটারে দুর্বল ইন্টারনেট স্পিডের সাথে একটি প্রোগ্রামকে রান করানো হলো, অন্যদিকে সেই প্রোগ্রামটি একটি সুপার কম্পিউটারের রান করানো হলো। তাহলে মোট রান টাইম এর তারতম্য থাকবে, তাই না? আসলে এখানে রানটাইম বলতে একটি অ্যালগরিদম বা প্রোগ্রামের প্রত্যেকটি অপারেশনের সমষ্টিকে বোঝায়।

এখন একটা প্রোগ্রামের অপারেশন কিভাবে নির্ণয় করে তা দেখে আসি। নিচের কোডটি লক্ষ্য করি,

```
   c = b+a
```

উপরের কোড টি তে মোট দুইটি অপারেশন আছে। `b+a` একটি অপারেশন এবং `b+a` এর মান কে c তে রাখা একটি অপারেশন। এখন অপারেশনের সমষ্টি থেকে কিভাবে টাইম কমপ্লেক্সিটি বের করা যায় তা আমরা সামনে আরো বিস্তারিত ভাবে দেখব।

## টাইম কমপ্লেক্সিটি কিভাবে নির্ণয় করা হয়?

এখন আমরা টাইম কমপ্লেক্সিটি নির্ণয়ের কিছু মাধ্যম সম্বন্ধে আলোচনা করব।

- Big-O notation - (worst-case complexity)
- Omega notation - (best case complexity)
- Theta notation - (average-case complexity)

প্রোগ্রামিং এর দুনিয়ায় সবচেয়ে বেশি `worst-case` complexity নিয়ে আলোচনা করা হয়। আমরাও এই ব্লগে `worst-case` complexity নিয়ে আলোচনা করব। কোথাও যখন শুধু টাইম কমপ্লেক্সিটি উল্লেখ করা হয় তখন আসলে `worst-case` complexity কে বোঝায়।

চলো আমরা এখন কিছু `worst-case` complexity নিয়ে আলোচনা করি।

## Constant time – O (1):

কোন অ্যালগরিদমের টাইম কমপ্লেক্সিটি O (1) হয় যখন ওই অ্যালগোরিদমের অপারেশন তার ইনপুটের আকারের উপর নির্ভর করে না।

```
//  assume n is input
 let a = 10;
let c = a + n;

```

এখন উপরের কোড টি তে কতগুলো অপারেশন আছে বের করি। `a=10` একটি অপারেশন, `a+n` একটি অপারেশন এবং `c = a + n` একটি অপারেশন। এখানে মোট তিনটি অপারেশন আছে। এখন আমরা একটু চিন্তা করি, আমরা যদি `n` এর মানের পরিবর্তন করি, তাহলে কি কোনভাবে এই তিনটা অপারেশনের বেশি অপারেশন রান করা সম্ভব? আমরা এই প্রোগ্রামে n মান যতই করি না কেন অপারেশনের সংখ্যা এই প্রোগ্রামের জন্য ধ্রুব। এর জন্য এই প্রোগ্রামের টাইম কমপ্লেক্সিটি `O(1)`।

এখন আমরা চিন্তা করি, নিচের প্রোগ্রামের টাইম কমপ্লেক্সিটি কত?

```
let sum = 0
for( let i =0; i<1;i++)
{
 	sum = n + i
}
```

এই প্রোগ্রামের মোট কতটি অপারেশন আছে তা দেখি,

এখানে, `sum = 0` হল ১ টি অপারেশান, `i=0` হল ১ টি অপারেশান, `i<1` হল ১ টি অপারেশান, `i++` হল ১ টি অপারেশান, এইভাবে `n+1`, `sum = n +1` এবং `i<1` ১ টি করে মোট ৭ টি অপারেশান হয়। এখন `n` এর মান পরিবর্তন করে কি মোট অপারেশন এর সংখ্যা পরিবর্তন করা সম্ভব? `n` এর মান যতই হোক না কানো এই প্রোগ্রামে ৭ টির বেশি অপারেশান সম্ভব না। এর জন্য এই প্রোগ্রামের টাইম কমপ্লেক্সিটি হবে `O(1)`।

মূলত মৌলিক অপারেশান (arithmetic, comparisons, accessing array’s elements, assignment) এর টাইম কমপ্লেক্সিটি হবে `O(1)`।

## Linear Time: O(n)

নিচের কোডটি লক্ষ্য করি,

```
for (int i = 0; i < n; i++)
 {
 console.log('Hello, World!!');
}
```

এখানে `n` ইনপুট এবং লুপটি চলবে 1 থেকে `n` পর্যন্ত। এখানে `i=0` এক্সিকিউট ১ বার , `i<n` এক্সিকিউট হবে `n+1` বার এবং `i++` এক্সিকিউট হবে `n` বার। তাহলে মোট অপারেশন হয় `{1+(n+1)+n} = 2n+2` বার । কোন অ্যালগোরিদমের টাইম কমপ্লেক্সিটি নির্ণয় সময় বড় ধ্রুব মানকে গণনা করতে বেশি উৎসাহিত করা হয়। তাই এখানে আমাদের টাইম কমপ্লেক্সিটি হবে `O(n)`।

কোন লুপ যদি 1 থেকে ইনপুট পর্যন্ত চলে তাহলে তার টাইম কমপ্লেক্সিটি হবে `O(n)` ।

কোন অ্যালগোরিদমের এক্সিকিউশন টাইম যদি ইনপুটের সমানুপাতিক হয় তাহলে সে আলগরিদম এর টাইম কমপ্লেক্সিটি `O(n)`।

## Quadratic Time: O(n^2)

```
for (int i = 0; i < n; i++)
 {
	for (int j= 0; j< n; j++){

   // কোন মৌলিক অপারেশান
}

}
```

উপরের লুপটি একটি নেক্সটেড লুপের এর উদাহরণ। এর মানে লুপের ভেতরে লুপ। বাইরের লুপটি `n` বার চলবে এবং ভেতরের লুপটি প্রত্যেকটি পুনরাবৃত্তিতে `n` বার চলবে। এখন যদি আমরা লক্ষ্য করি প্রথমের লুপটির মোট অপারেশন `2n` এবং ইনার লুপ বা ভেতরের লুপটির অপারেশন `2n^2`। তাহলে মোট অপারেশনের সংখ্যা দাঁড়ায় `2n+2n^2`। আমরা আগেই জানি, টাইম কমপ্লেক্সিটি হিসেবে আমরা ধ্রুব এবং বড় মানটি নেব । তাই উপরের প্রোগ্রামের টাইম কমপ্লেক্সিটি হবে `O(n^2)`।

## Logarithm Time: O(log n)

```
for (int i = n; i > 0; i /= 2) {
// some O(1) expressions

}

```

আমরা উপরের কোডটি লক্ষ্য করি। কোডটির ইনপুট `n` থেকে 1 পর্যন্ত চলবে, কিন্তু প্রত্যেক পুনরাবৃত্তিতে `n` এর মান অর্ধেক করে কমবে। এই প্রোগ্রামের টাইম কমপ্লেক্সিটি `0(logn)`।

কোন অ্যালগোরিদমের এক্সিকিউশন টাইম তার ইনপুটের অর্ধেকের সমানুপাতিক হলে সেই অ্যালগোরিদমের টাইম কমপ্লেক্সিটি 0(logn)।

## Exponential Time: O(2^n)

নিচের কোডটি লক্ষ্য করি,

```
int Fibonacci(int n)
{
 if (number <= 1) return n;
return Fibonacci(n - 2) + Fibonacci(n - 1);
}

```

এটি একটি Fibonacci সংখ্যা বের করার কোড। Fibonacci সিরিজ লেখা হয় আগের দুটি সংখ্যার যোগফল দিয়ে। Fibonacci সিরিজের উদাহরণ নিচে দেওয়া হল

![image-1](/static/images/courses/learn-problem-solving-basic/24-time-complexity-2.png)

আগের দুটি সংখ্যা যোগ করে পরবর্তী সংখ্যাটি পাওয়া যায়:

আগের দুটি সংখ্যা যোগ করে 2 পাওয়া যায় (1+1), 3 এর আগে দুটি সংখ্যা যোগ করে 3 পাওয়া যায় (1+2), 5 হল (2+3), এইভাবে চলতে থাকবে।

এখন দেখি এই অ্যালগোরিদমে কতটি অপারেশন এক্সিকিউট হয়।

![image-2](/static/images/courses/learn-problem-solving-basic/24-time-complexity-1.png)

এখানে লেভেল 1 এ অপারেশন 2 টি , লেভেল 2 এ অপারেশন 4 টি এবং লেভেল 3 এ অপারেশন 8 টি । একটু লক্ষ্য করলে আমরা দেখতে পাব অপারেশন সংখ্যা `2^লেভেল`। এখন শেষ লেভেল থেকে যদি আমরা টাইম কমপ্লেক্সিটি বের করার চেষ্টা করি তাহলে তা দাঁড়াবে `O(2^n-1)`। আমরা আগেই জানি, টাইম কমপ্লেক্সিটি নির্ণয়ে আমরা কোন ছোট ধ্রুব মানকে অবজ্ঞা করি। তাহলে এই অ্যালগরিদমের টাইম কমপ্লেক্সিটি হবে `O(2^n)` ।

যখন ইনপুট প্রতিটি সংযোজনের সাথে বৃদ্ধির হার দ্বিগুণ হয়, তখন তা হয় `O(2^n)`।

এখন আমাদের মনে প্রশ্ন আসতে পারে, এতগুলো টাইম কমপ্লেক্সিটি মধ্যে কোনটি অ্যালগরিদমের জন্য ভালো? টাইম কমপ্লেক্সিটি গুলোর কার্যকারিতার একটি তালিকা নিচে দেওয়া হল,

- O(1) - Excellent/Best
- O(log n) - Good
- O(n) - Fair
- O(n^2), O(2^n) - Horrible/Worst

## টাইম কমপ্লেক্সিটি চিটশিট

- যখন ইনপুট আকারের উপর নির্ভরশীল নয়, এটি একটি ধ্রুবক সময়ের জটিলতা `(O(1))`।
- কোন অ্যালগোরিদমের এক্সিকিউশন টাইম তার ইনপুটের অর্ধেকের সমানুপাতিক হলে সেই অ্যালগোরিদমের টাইম কমপ্লেক্সিটি `0(logn)`
- যখন আপনার অ্যালগরিদমের মধ্যে একটি একক লুপ থাকে, তখন এটি `(O(n))`।
- যখন আপনার অ্যালগরিদমের মধ্যে নেস্টেড লুপ থাকে, লুপ দুইটি 1 থেকে ইনপুট পর্যন্ত চলে তখন তার টাইম কমপ্লেক্সিটি `(O(n^2))`।
- যখন ইনপুট প্রতিটি সংযোজনের সাথে বৃদ্ধির হার দ্বিগুণ হয়, তখন তা হয় `O(2^n)`।
